# MySQL面试题

<!-- vscode-markdown-toc -->
* 1. [MySQL的存储引擎](#MySQL)
* 2. [MySQL表的磁盘存储方式](#MySQL-1)
* 3. [InnoDB引擎的存储特性](#InnoDB)
* 4. [MyISAM存储引擎](#MyISAM)
* 5. [如何理解TEMPORARY类型的表](#TEMPORARY)
* 6. [MySQL的索引特性](#MySQL-1)
* 7. [请说说ALL,ANY和SOME子查询](#ALLANYSOME)
* 8. [如何改写用来查询非匹配(缺失)值的子查询为连接语句](#)
* 9. [说说UNION的特性](#UNION)
* 10. [如何级联删除](#-1)
* 11. [什么是MySQL的事务](#MySQL-1)
* 12. [事务的特性](#-1)
* 13. [并发事务带来的问题](#-1)
* 14. [不可重复读和幻读的区别](#-1)
* 15. [MySQL事务的隔离级别](#MySQL-1)
* 16. [MySQL四种事务隔离级别是如何实现的](#MySQL-1)
* 17. [可重复度在MySQL中具体怎么实现的](#MySQL-1)
* 18. [MySQL的回滚日志](#MySQL-1)
* 19. [MySQL锁](#MySQL-1)
* 20. [什么是参照完整性](#-1)
* 21. [存储过程与存储函数的区别](#-1)
* 22. [什么是触发器](#-1)
* 23. [什么是事件](#-1)
* 24. [数据库的三范式](#-1)

<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->

##  1. <a name='MySQL'></a>MySQL的存储引擎

MySQL支持多种存储引擎。每一种存储引擎所实现的表都具有一组特定的属性或者特性。在MySQL中我们最经常使用的就是InnoDB和MyISAM存储引擎。实际上MySQL的存储引擎远不止如此。见下表:

|  存储引擎  |                             描述                             |
| :--------: | :----------------------------------------------------------: |
|  ARCHIVE   |       用于数据存档的引擎(行被插入之后就不能在被修改了)       |
| BLACKHOLE  |        这种存储引擎会丢弃读写数据，读操作会返回空内容        |
|    CSV     | 这种存储引擎在存储数据的时候，会以逗号作为数据项之间的分隔符 |
| FEDERATED  |                   用来访问远程表的存储引擎                   |
| **InnoDB** |              **具备外键支持功能的事务处理引擎**              |
|   MEMORY   |                         置于内存的表                         |
|   MERGE    |               用来管理多个MyISAM表构成的表集合               |
| **MyISAM** |                 **主要的非事务处理存储引擎**                 |
|    NDB     |                    MySQL集群专属存储引擎                     |

如果我们要想查看MySQL有哪些存储引擎可以用，当然，这取决于MySQL的版本，可以通过下面的指令:

```mysql
mysql> SHOW ENGINES\G
```

或

```mysql
mysql> SELECT ENGINE FROM INFORMATION_SCHEMA.ENGINES;
```

如果我们想要查看支持事务的引擎，则可以通过下面的指令:

```mysql
mysql> SELECT ENGINE FROM INFORMATION_SCHEMA.ENGINES WHERE TRANSACTIONS = 'YES';
```

##  2. <a name='MySQL-1'></a>MySQL表的磁盘存储方式

每次在创建表的时候，MySQL都会创建一个磁盘文件，用来保存该表的格式，这个格式的文基本名与表名一致，扩展名为`.frm` 。 `frm`文件不会发生变化，因为无论管理这个表的存储引擎是哪一种，每个表都会只有一个与之对应的`.frm`文件。

各个存储引擎可能还会为表再创建几个特定的文件，用来存储表的内容，对于某个特定的表，与之相关的所有文件都会被放置到这个表的那个数据库对应的目录中。下表列出了几种由某个存储引擎创建的与表相关的文件扩展名。

| 存储引擎 |     磁盘文件扩展名      |
| :------: | :---------------------: |
|  InnoDB  |    .ibd(数据和索引)     |
|  MyISAM  |  .MYD(数据) .MYI(索引)  |
|   CSV    | .CSV(数据) .CSM(元数据) |

**默认情况下，InnoDB存储引擎会把表的数据和索引的数据存储在它的系统表空间中。也就是说，所有的InnoDB表的内容全都存储在一个共享的存储区域中，而不是某个特定的表所特有的文件里面**

##  3. <a name='InnoDB'></a>InnoDB引擎的存储特性

InnoDB存储引擎是MySQL的默认存储引擎，主要有下面的特性:

1. 其表在执行提交和回滚操作时是事务安全的，可以通过创建保存点(savepoint)来实现数据库的回滚。
2. 在系统崩溃之后可以自动恢复
3. 外键和引用完整性支持，包括级联删除和更新
4. 基于行级别的锁定和多版本化，使得在执行同时包含有检索和更新操作的组合条件查询时，可以表现出很好的并发性能。
5. 从MySQL5.6版本开始，InnoDB支持全文检索和FULLTEXT检索
6. 默认情况下，InnoDB存储引擎会把表集中存储在一个系统表空间中，而不是像其他存储引擎那样为不同的表创建不同的文件。**实际上，InnoDB存储引擎会把表空间当成是一个虚拟的文件系统，它会在其中存储和管理所有InnoDB表的内容，这样一来，表的长度就可以超过文件系统对单个文件的最大长度限制。同时，你也可以配置InnoDB使它为每一个表分别创建一个表空间，这样每一个表都会有.ibd文件**

##  4. <a name='MyISAM'></a>MyISAM存储引擎

MyISAM是MySQL**主要的非事务存储引擎** ，其特性如下:

1. 当保存连续相似的字符串索引值时，它会对键进行压缩，此外MyISAM还可以压缩相似的数字索引值，因为这些数值都是以高字节为优先的方式来进行保存的。 **MyISAM以低字节优先表示索引值的时候，检索速度更快，以高字节为优先表示时，更易于压缩** 。如果想启动MyISAM的数字压缩功能，在创建MyISAM的时候使用`PACK_KEYS=1`选项。
2. 与其他存储引擎相比，MyISAM为`AUTO_INCREMENT`提供了更多的功能。
3. 每个MyISAM都有一个标志，它会在执行表检查操作时被设置。MyISAM表还会有一个标志，用于表明该表在上次使用后是否被正常关闭，如果服务器发生意外的宕机，可以用这个标志来检查是否需要修复。如果想进行自动检查，则需要在启动服务器的时候，将`myisam_revover_options`系统变量设置为一个包含有`FORCE`选项的值，这样，在每次打开MyISAM表的时候，服务器便会自动检查该表的标志，并根据需要进行表的修复。
4. 支持全文检索和FULLTEXT索引
5. 支持空间数据类型和SPATIAL索引

##  5. <a name='TEMPORARY'></a>如何理解TEMPORARY类型的表

TEMPORAY表字如其名，是属于临时表，**其存储在的时间范畴仅在服务器会话存活的时间** ，具体创建的语句如下:

```mysql
mysql> CREATE TEMPORARY TABLE t (...)
```

TEMPORARY表与某个已有的永久表的名字相同，已经存在的永久表的内容也不会遭到损坏。

##  6. <a name='MySQL-1'></a>MySQL的索引特性

索引时加快访问表内容的基本手段，尤其是在涉及多个表的关联查询里面，这是一个非常重要的话题。MySQL提供了多个灵活的索引创建办法:

1. 可以对单个列或者多个列建立索引，多列索引也被称为复合索引
2. 索引可以只包含唯一值，也可以包含重复值
3. 可以为同一个表创建多个索引，帮助优化对表的不同类型的查询
4. 对于除`ENUM`和`SET`以外的字符串类型，可以利用列的前缀创建索引，也就是说，只对列名的最左边n个字符或者n个字节创建索引(对于BLOB和TEXT列，只有在制定了前缀长度的情况下才能创建索引) 。如果要在前缀长度范围内，大部分的列都具有唯一性，那么查询性能通常不会受到影响，并且还可能得到改善，具体表现在，为列的前缀而不是整个列进行索引，可以让索引变得更小，访问速度更快

**然后并非所有的MySQL存储引擎都支持索引功能** ，不同MySQL的存储引擎的特性见下表:

|        索引特性        |   InnoDB   | MyISAM | MEMORY |
| :--------------------: | :--------: | :----: | :----: |
| 索引列是否允许使用NULL |     Y      |   Y    |   Y    |
|  每个索引的列数(最大)  |     16     |   16   |   16   |
|     每个表的索引数     |     64     |   64   |   64   |
| 索引行的最大长度(字节) |    3072    |  1000  |  3072  |
|    是否支持前缀索引    |     Y      |   Y    |   Y    |
| 列前缀的最大长度(字节) |    767     |  1000  |  3072  |
| 是否支持BLOB/TEXT索引  |     Y      |   Y    |   N    |
|  是否支持FULLTEXT索引  | 5.6.4版本+ |   Y    |   N    |
|  是否支持SPATIAL索引   |     N      |   Y    |   N    |
|    是否支持HASH索引    |     N      |   N    |   Y    |

要想创建索引，我们可以通过下面的语句:

```mysql
mysql> CREATE INDEX index_name ON tbl_name (index_columns);
mysql> CREATE UNIQUE INDEX index_name ON tbl_name (index_columns);
mysql> CREATE FULLTEXT INDEX index_name ON tbl_name (index_columns);
mysql> CREATE SPATIAL INDEX index_name ON tbl_name (index_columns);
```

##  7. <a name='ALLANYSOME'></a>请说说ALL,ANY和SOME子查询

运算符ALL和ANY常与某个关系比较运算符结合在一起使用，以便测试列子查询的结果。他们会测试比较值与子查询返回的全部或者部分值是否匹配。 **注意ALL,ANY,SOME仅在子查询的情况下使用**

例如当我们想要查找某个**出生日期最早的那个人的信息** ，可以用下面的语句:

```mysql
mysql> SELECT name, birth FROM president
    -> WHERE birth <= ALL (SELECT birth FROM president);
```

当ALL, ANY, SOME与比较运算符"="配合使用的时候，子查询可以是表子查询，此外，需要使用一个**行构造器**来提供比较值:

```mysql
mysql> SELECT name, city, state FROM president
    -> WHERE (city, state) = ANY
    -> (SELECT city, state FROM president
    -> WHERE name = 'Robot');
```

**需要提一点的是，IN和NOT IN是=ANY和<>ANY的同义词，SOME是ANY的同义词**

##  8. <a name=''></a>如何改写用来查询非匹配(缺失)值的子查询为连接语句

比如我们想要测试哪些学生没有出现在absence表中:

```mysql
mysql> SELECT * FROM student
    -> WHERE student_id NOT IN (SELECT student_id FROM absence);
```

上述语句使用到了子查询，若想改成连接语句，可以使用下面的LEFT JOIN来实现:

```mysql
mysql> SELECT student.* FROM student
    -> LEFT JOIN absence ON student.student_id = absence.student_id
    -> WHERE absence.student_id IS NULL;
```

##  9. <a name='UNION'></a>说说UNION的特性

UNION有以下几种特性:

1. **列名和数据类型** :UNION结果集里的列名来自第一个SELECT里的列名。UNION中的第二个及后面的SELECT必须选取 相同个数的列，但各列可以有不同的列名和数据类型， **但是出于严谨的目的，数据类型最好相同**
2. **重复行的处理** :在默认情况下，MySQL使用UNION时会将结果集里的重复行剔除，默认情况下，UNION也是DISTINCT UNION的同义词
3. **ORDER BY和LIMIT处理** :如果想将UNION结果作为一个整体进行排序，那么需要用括号把每一个SELECT语句括起来，并在最后的那个SELECT语句后面再加上一个ORDER BY子句。因为UNION会使用第一个SELECT语句里的列名。所以ORDER BY子句必须引用那些句子，而不能引用最后那个SELECT语句。例如：

```mysql
mysql> (SELECT i, c FROM t1) UNION (SELECT i, d FROM t3) ORDER BY c;
```

```mysql
mysql> (SELECT * FROM a) UNION (SELECT * FROM b) UNION (SELECT * FROM c) LIMIT 2;
```

子句ORDER BY和LIMIT还可以用在被括号括起来的单个SELECT里，从而**只会对这条SELECT语句起作用** :

```mysql
mysql> (SELECT * FROM t1 ORDER BY i LIMIT 2)
    -> UNION (SELECT * FROM t2 ORDER BY j LIMIT 2)
    -> UNION (SELECT * FROM t2 ORDER BY d LIMIT 2);
```

##  10. <a name='-1'></a>如何级联删除

如果要从表t1中删除存在于表t2中的id的所有行，可以用如下语句:

```mysql
mysql> DELETE t1 FROM t1 INNER JOIN t2 ON t1.id = t2.id;
```

如果要同时删除t1, t2中含相同id的所有行，可以用如下语句：

```mysql
mysql> DELETE t1, t2 FROM t1 INNER JOIN t2 ON t1.id = t2.id;
```

如果想要删除t1中不存在于t2的id所有行，可以使用如下语句：

```mysql
mysql> DELETE t1 FROM t1 LEFT JOIN t2 ON t1.id = t2.id WHERE t2.id = NULL;
```

**总之，DELETE搭配连接可以完成几乎所有的级联删除操作**

##  11. <a name='MySQL-1'></a>什么是MySQL的事务

事务是逻辑上的一组操作，要么都执行，要么都不执行。

事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。

##  12. <a name='-1'></a>事务的特性

事务的特性可以被简写为ACID，解释如下：

- **原子性**： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
- **一致性**： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；
- **隔离性**： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
- **持久性**： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

##  13. <a name='-1'></a>并发事务带来的问题

在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。

- **脏读（Dirty read）**: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
- **丢失修改（Lost to modify）**: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。
- **不可重复读（Unrepeatableread）**: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
- **幻读（Phantom read）**: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

##  14. <a name='-1'></a>不可重复读和幻读的区别

不可重复读的重点是修改，幻读的重点在于新增或者删除。

例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。

例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。

##  15. <a name='MySQL-1'></a>MySQL事务的隔离级别

SQL 标准定义了四个隔离级别：

- **READ-UNCOMMITTED(读取未提交)**： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
- **READ-COMMITTED(读取已提交)**： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
- **REPEATABLE-READ(可重复读)**： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
- **SERIALIZABLE(可串行化)**： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

|  事务隔离级别   | 脏读 | 幻读 | 不可重复读 |
| :-------------: | :--: | :--: | :--------: |
| READ UNCOMMITED |  √   |  √   |     √      |
|  READ COMMITED  |  ×   |  √   |     √      |
| REPEATABLE READ |  ×   |  √   |     ×      |
|  SERIALIZABLE   |  ×   |  ×   |     ×      |

##  16. <a name='MySQL-1'></a>MySQL四种事务隔离级别是如何实现的

- **读未提交**: 没有任何操作，该读就读，该改就改
- **读提交**: 与可重复度的区别就是，view的创建发生在每次SQL语句之前
- **可重复度**: 在**事务启动的时候**，会创建一个原来表的视图view，之后的读取全部都是读取这个view
- **串行化**: 通过给表进行加锁

##  17. <a name='MySQL-1'></a>可重复度在MySQL中具体怎么实现的

假设有A,B,C三个事务均需要使用表t，那么A,B,C事务启动的时候就会创建view_A, view_B, view_C三个视图，MySQL在每一条更新操作语句的同时又记录了一条**回滚操作**，更新过后的值，都可以通过回滚操作恢复到以前的值。

##  18. <a name='MySQL-1'></a>MySQL的回滚日志

MySQL回滚日志有的时候比数据本身的文件还要大，常常会出现数据20G，但是回滚日志200G，为了清除回滚日志不得不重建数据库，这也是为什么不推荐使用长事务的原因

回滚日志的清除发生在**没有事务使用到这个回滚记录的时候就删除** 。

##  19. <a name='MySQL-1'></a>MySQL锁

假设事务A锁住了表T里的一行记录，这时候，你执行了一个DDL语句，想给这张表加个字段，这时候需要锁表吧？但是由于表里有一行记录被锁住了，所以这时候锁表时会 block。

那 MySQL 在锁表时，怎么判断表里有没有记录被锁住呢？

最简单暴力的，遍历整张表，遍历每行记录，遇到一个锁，就说明表里加锁了。

这样做可以，但是很傻，性能很差，高性能的 Mysql，不允许这样的做法存在。

MySQL 会怎么做呢？

行锁是行级别的，粒度比较小，好，那我要你在拿行锁之前，必须先拿一个假的表锁，表示你想去锁住表里的某一行或者多行记录。

这样，MySQL 在判断表里有没有记录被锁定，就不需要遍历整张表了，它只需要看看，有没有人拿了这个假的表锁。

这个假的表锁，就是我们常说的，**意向锁(Intention Lock)**。

##  20. <a name='-1'></a>什么是参照完整性

**我们常常希望保证在一个关系中给定属性集上的取值也在另一个关系的特定属性集的取值中出现。这种情况称为参照完整性(referential integrity)**

参照完整性的使用规则如下：

```mysql
[CONSTRAINT constraint_name]
FOREIGN KEY [fk_name] (index_columns)
REFERENCES tbl_name (index_columns)
	[ON DELETE ACTION]
	[ON UPDATE ACTION]
	[MATCH FULL | MATCH PARTIAL | MATCH SIMPLE]
```

* `ON DELETE`可以用来指定删除父表的行时，子表应该做什么， **如果没有`ON DELETE`语句，那么其默认行为将是“拒绝从父表里删除仍被子表的行所引用的那些行”** 。如果想显式地指定一种ACTION，那么可以选取如下:
  * **`ON DELETE NO ACTION`和`ON DELETE RESTRICT`** :延迟检查
  * **`ON DELETE CASCADE`** :删除父表里的行时，子表里与之关联的行也会被删除
  * **`ON DELETE SET NULL`** :删除父表时，子表与之关联的所有索引列都会被设置为NULL(这种情况下列不能为主键)
  * **`ON DELETE SET DEFAULT`** :删除父表时，子表与之关联的所有索引列都会被设置为默认值

* `ON UPDATE`用来指定更新父表的行时，子表应该做什么。 **如果没有`ON UPDATE`,其默认行为将是在子表里，拒绝执行那些会导致其外键值在父索引里无任何匹配的插入和更新操作** 。其余的选项和`ON DELETE`相同。

##  21. <a name='-1'></a>存储过程与存储函数的区别

存储过程和函数是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的

存储过程和函数的区别在于函数必须有返回值，而存储过程没有，存储过程的参数可以使用 in，out，inout 类型，而函数的参数只能是 in 类型的。如果有函数从其他类型的数据库迁移到 MySQL，那么就可能因此需要将函数改造成存储过程

##  22. <a name='-1'></a>什么是触发器

**触发器是与特定表相关联的存储过程** ，其定义会在执行表的INSERT, DELETE, UPDATE语句时自动激活。触发器可以被设置为语句处理各行之前或者之后激活。触发器的定义包含有一条会在触发器被激活时执行的语句。

* 触发器可以检查或修改将被插入或者更新的行的那些新的数据值。这意味着我们可以利用触发器来实现数据完整性约束。
* 触发器可以基于某个表达式来为列提供默认值，甚至可以为那些只能使用常量默认值进行定义的列提供值。
* 触发器可以在行删除或者更新之前先检查行的当前内容，这种能力能完成需要任务，如记录已有行的更改情况。

##  23. <a name='-1'></a>什么是事件

MySQL有一个事件调度器，它可以定时激活多个数据库的操作。**事件就是一个与计划相关联的存储程序**。默认情况下，事件调度器并不会运行，因此必须先启动它才能使用事件，启动分为冷启动和热启动。

冷启动需要修改MySQL配置参数，如下:

```properties
[mysqld]
event_schedular=ON
```

热启动需要修改`event_schedular`系统变量，如下:

```mysql
mysql> SET GLOBAL event_schedular = ON;
```

事件执行器会把执行情况写进服务器的错误日志里，通过它，你可以查看到事件调度器正在做什么。在事件执行期间，只要有错误发生，事件调度器都会把他们记录下来。

事件属于数据库，因此必须要具有数据库的`EVENT`权限才可以创建或者删除触发器。

##  24. <a name='-1'></a>数据库的三范式

* **第一范式** :要求列或者属性原子不可分
* **第二范式** :实体的属性完全依赖于主属性。所谓完全依赖是指不能仅存在仅依赖主属性一部分的属性，如果存在，那么这个非依赖属性和主属性需要分离成两个单独的实体，新实体与原实体是一对多的关系。
* **第三范式** :每一列只能有一个值，每一行都能区分，每一个表都不能包含别的表已经包含的非主属性